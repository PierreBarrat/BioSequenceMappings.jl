var documenterSearchIndex = {"docs":
[{"location":"","page":"Home","title":"Home","text":"CurrentModule = BioSequenceMappings","category":"page"},{"location":"#BioSequenceMappings","page":"Home","title":"BioSequenceMappings","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Documentation for BioSequenceMappings.","category":"page"},{"location":"","page":"Home","title":"Home","text":"","category":"page"},{"location":"","page":"Home","title":"Home","text":"Modules = [BioSequenceMappings]","category":"page"},{"location":"#BioSequenceMappings.Alignment","page":"Home","title":"BioSequenceMappings.Alignment","text":"mutable struct Alignment{A,T} where {A, T<:Integer}\n\n    dat::Matrix{T}\n    alphabet::Union{Nothing, Alphabet{A,T}}\n    weights::Vector{Float64} = ones(size(dat,1))/size(dat,1) # phylogenetic weights of sequences\n    names::Vector{String} = fill(\"\", size(dat, 1))\n\nBiological sequences as vectors of type T<:Integer. dat stores sequences in columns: size(dat) returns a tuple (L, M) with L the length and M the number of sequences.\n\nalphabet{A,T} represents the mapping between integers in dat and biological symbols of type A (nucleotides, amino acids...). If nothing, the alignment cannot be mapped to biological sequences.\n\nweights represent phylogenetic weights, and are initialized to 1/M. They must sum to 1. names are the label of sequences, and are expected to be in the same order as the columns of dat. They do not have to be unique, and can be ignored\n\nImportant: When built from a matrix, will transpose the input; if size(dat) = (M, L),\n\nX=Alignment(dat, alphabet) will return an object with size(X.dat) = (L, M).\n\nIn other words, assumes that the input matrix has sequences as rows.\n\nMethods\n\ngetindex(X::Alignment, i) returns a matrix/vector X.dat[:, i].\nfor s in X::Alignment iterates over sequences.\neachsequence(X::Alignment) returns an iterator over sequences (Vector{Int}).\neachsequence_weighted(X::Alignment) returns an iterator over sequences and weights as tuples\nsubaln(X::Alignment, idx) constructs the subaln defined by index idx.\n\n\n\n\n\n","category":"type"},{"location":"#BioSequenceMappings.Alignment-Union{Tuple{AbstractMatrix{T}}, Tuple{T}} where T<:Integer","page":"Home","title":"BioSequenceMappings.Alignment","text":"Alignment(data::AbstractMatrix{T}; alphabet = :auto, kwargs...)\n\nKeyword argument alphabet can be :auto, :none or nothing, or an input to Alphabet. Other keyword arguments are passed to the default constructor of Alignment.\n\n\n\n\n\n","category":"method"},{"location":"#BioSequenceMappings.Alignment-Union{Tuple{T}, Tuple{A}, Tuple{AbstractMatrix{T}, Alphabet{A, T}}} where {A, T}","page":"Home","title":"BioSequenceMappings.Alignment","text":"Alignment(data::AbstractMatrix, alphabet; kwargs...)\n\ndata is a matrix of integers. alphabet can be either     - an Alphabet     - nothing     - something to build an alphabet from: the constructor Alphabet will be called.     (e.g. a symbol like :aa, a string, ...)\n\nIf the types of alphabet and data mismatch, data is converted.\n\n\n\n\n\n","category":"method"},{"location":"#BioSequenceMappings.Alphabet","page":"Home","title":"BioSequenceMappings.Alphabet","text":"struct Alphabet{A,I}\n    characters::Vector{A}\n    char_to_index::Dict{A, I}\n    index_to_char::Dict{I, A}\nend\n\nAlphabet can be constructed\n\nfrom a Vector of symbols and an optional type, e.g. Alphabet(['A','C','G','I'], UInt8)\nfrom a String and an optional type: Alphabet(string::String[, I<:Integer])\nfrom a mapping Dict{A, I} where I<:Integer: Alphabet(mapping)\nfrom a Symbol, using default alphabets\nfrom an integer, using default alphabets (see default_alphabets).\n\n\n\n\n\n","category":"type"},{"location":"#BioSequenceMappings.compute_mapping-Union{Tuple{AbstractVector{A}}, Tuple{I}, Tuple{A}, Tuple{AbstractVector{A}, Type{I}}} where {A, I<:Integer}","page":"Home","title":"BioSequenceMappings.compute_mapping","text":"compute_mapping(s::AbstractString)\n\nReturn a Dict{Int, Char}: Dict(i => c for (i,c) in enumerate(s)).\n\n\n\n\n\n","category":"method"},{"location":"#BioSequenceMappings.compute_weights","page":"Home","title":"BioSequenceMappings.compute_weights","text":"compute_weights(X::AbstractAlignment, θ = 0.2; normalize = true)\n\nCompute phylogenetic correction weights for sequences of X.     The weight sequence S is 1/N, where N is the number of sequences in X at     hamming distance less than H from S (including S itself).     The threshold H is floor(θ⋅L) where L is the sequence length.\n\nThe return value is a tuple (weights, Meff), where Meff is the sum of weights (pre-normalization). If normalize, weights are normalized to sum to one. .\n\n\n\n\n\n","category":"function"},{"location":"#BioSequenceMappings.compute_weights!-Tuple{Any, Any}","page":"Home","title":"BioSequenceMappings.compute_weights!","text":"compute_weights!(X, θ; kwargs...)\n\nCompute and set weights for X. See compute_weights.\n\n\n\n\n\n","category":"method"},{"location":"#BioSequenceMappings.default_alphabet-Union{Tuple{Integer}, Tuple{T}, Tuple{Integer, Type{T}}} where T<:Integer","page":"Home","title":"BioSequenceMappings.default_alphabet","text":"default_alphabet(q::Int, T::Type)\n\nif q==21, amino acids\nif q==5, nucleotides\nif q==4, nucleotides without gaps\nif q==2, binary (0, 1)\nelse, if q<21, return the restriction of amino acids to the first q sites\nif q>21, fails\n\n\n\n\n\n","category":"method"},{"location":"#BioSequenceMappings.find_sequence-Tuple{AbstractString, AbstractAlignment}","page":"Home","title":"BioSequenceMappings.find_sequence","text":"find_sequence(label::AbstractString, aln::AbstractAlignment)\n\nFind sequence label in aln, and return (index, sequence). Scales as the number of sequences.\n\n!!! Return a view of the sequence.\n\n\n\n\n\n","category":"method"},{"location":"#BioSequenceMappings.hamming-Tuple{AbstractVector{<:Integer}, AbstractVector{<:Integer}}","page":"Home","title":"BioSequenceMappings.hamming","text":"hamming(x, y; normalize=true, positions=nothing)\n\nHamming distance between Vectors x and y. Only sites in vector positions will be considered.\n\n\n\n\n\n","category":"method"},{"location":"#BioSequenceMappings.match_sequences-Tuple{Any, AbstractAlignment}","page":"Home","title":"BioSequenceMappings.match_sequences","text":"match_sequences(pattern, aln::AbstractAlignment)\n\nFind sequences that match label in aln, and return (indices, sequences). Sequences are returned as columns.\n\n!!! Return a view of the sequences.\n\n\n\n\n\n","category":"method"},{"location":"#BioSequenceMappings.pairwise_hamming-Tuple{Alignment, Alignment}","page":"Home","title":"BioSequenceMappings.pairwise_hamming","text":"pairwise_hamming(X, Y; step=1, step_left, step_right)\n\nReturn matrix of all hamming distances between sequences of X and Y. Only consider sequences every step. step_left and step_right can be used to skip sequence either in X or in Y:\n\n\n\n\n\n","category":"method"},{"location":"#BioSequenceMappings.pairwise_hamming-Tuple{Alignment}","page":"Home","title":"BioSequenceMappings.pairwise_hamming","text":"pairwise_hamming(X; step, as_vec=true)\n\nVector of pairwise hamming distances of sequences in X, ordered as [H(1,2), H(1,3), ..., H(M-1, M)] with H standing for hamming distance. If as_vec=false, will return a Matrix instead.\n\n\n\n\n\n","category":"method"},{"location":"#BioSequenceMappings.read_fasta-Tuple{AbstractString}","page":"Home","title":"BioSequenceMappings.read_fasta","text":"read_fasta(fastafile::AbstractString; alphabet = :auto, kwargs...)\nread_fasta(\n    fastafile::AbstractString, alphabet;\n    weights = false, theta = 0.2, verbose = false,\n)\n\n\n\n\n\n","category":"method"},{"location":"#BioSequenceMappings.site_specific_frequencies-Tuple{Any, Vararg{Any}}","page":"Home","title":"BioSequenceMappings.site_specific_frequencies","text":"site_specific_frequencies(X::AbstractAlignment, weights=nothing; as_vec=true)\n\nReturn the site specific frequencies of X. If as_vec (default), the result is a vector of length Lxq. Otherwise, it is a matrix of q rows and L columns\n\n\n\n\n\n","category":"method"},{"location":"#BioSequenceMappings.subsample-Tuple{AbstractAlignment, Int64}","page":"Home","title":"BioSequenceMappings.subsample","text":"subsample(X::AbstractAlignment, indices)\n\nReturn an Alignment containing only the sequences of X at indices.\n\n\n\n\n\n","category":"method"},{"location":"#BioSequenceMappings.subsample_random-Tuple{AbstractAlignment, Int64}","page":"Home","title":"BioSequenceMappings.subsample_random","text":"subsample_random(X::AbstractAlignment, m::Int)\n\nReturn an Alignment with m sequences taking randomly from X. Sampling is done without replacement, meaning the m sequences are all at different positions in X.\n\n\n\n\n\n","category":"method"},{"location":"#BioSequenceMappings.symbols-Tuple{Alphabet}","page":"Home","title":"BioSequenceMappings.symbols","text":"symbols(alphabet)\n\nReturn the vector of symbols/characters used by alphabet.\n\n\n\n\n\n","category":"method"},{"location":"#BioSequenceMappings.translate-Tuple{Integer, Alphabet, Alphabet}","page":"Home","title":"BioSequenceMappings.translate","text":"translate(x, original_alphabet::Alphabet, new_alphabet::Alphabet)\n\nReturn the translation in new_alphabet of an integer or a vector of integers x that is expressed in original_alphabet.\n\n\n\n\n\n","category":"method"}]
}
